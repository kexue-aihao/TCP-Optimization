# 0. FQ_PIE队列算法核心配置（全局启用+对称2Gbps适配）
net.core.default_qdisc = fq_pie                  # 全局默认队列算法设为FQ_PIE（替代默认pfifo_fast，必开）
net.ipv4.tcp_congestion_control = bbr            # 拥塞控制保持BBR，与FQ_PIE协同优化
# FQ_PIE关键参数（匹配对称2Gbps带宽）
net.core.fq_pie.target_delay = 12                # 目标延迟12ms（对称高带宽下降低延迟，避免上下行队列叠加）
net.core.fq_pie.max_queue_size = 55000           # 最大队列长度5.5万包（适配2Gbps上下行，缓冲约0.03秒，无丢包风险）
net.core.fq_pie.packet_limit = 2500              # 单个流最大数据包限制2500（对称带宽下单线程占比提升，保障满速）
net.core.fq_pie.alpha = 7                        # PIE算法alpha系数7（轻度惩罚拥塞，适配对称带宽平稳性）
net.core.fq_pie.beta = 14                        # PIE算法beta系数14（与alpha匹配，快速响应拥塞但不激进丢包）
net.core.fq_pie.max_burst = 120                  # 最大突发数据包120（适配BBR对称带宽突发窗口，避免误判）

# 1. TCP窗口核心配置（对称2Gbps单线程满速）
net.ipv4.tcp_rmem = 4194304 33554432 83886080    # 接收窗口（下行）：4MB - 33MB - 80MB（从60MB→80MB，匹配2Gbps单线程）
net.ipv4.tcp_wmem = 4194304 33554432 83886080     # 发送窗口（上行）：4MB - 33MB - 80MB（保持80MB，与下行对称）
net.core.rmem_default = 24159191040              # 默认接收缓冲区24MB（从16MB→24MB，下行初始速率拉满2Gbps）
net.core.wmem_default = 24159191040              # 默认发送缓冲区24MB（保持24MB，与下行对称，上行初始速率拉满）
net.core.rmem_max = 83886080                     # 最大接收缓冲区80MB（从60MB→80MB，下行2Gbps硬上限）
net.core.wmem_max = 83886080                     # 最大发送缓冲区80MB（保持80MB，上行2Gbps硬上限）
net.ipv4.tcp_window_scaling = 1                  # 启用窗口缩放（支撑80MB大窗口，必开）
net.ipv4.tcp_moderate_rcvbuf = 0                  # 禁用智能缓冲区（锁定大窗口，避免FQ_PIE队列空转）
net.ipv4.tcp_adv_win_scale = 0                   # 窗口缩放因子最大化（实际可用窗口提升100%，对称带宽适配）

# 2. BBR拥塞控制（对称2Gbps优化）
net.ipv4.tcp_bbr_high_gain = 3300000000          # 激进增益3.3e9（从3.2e9→3.3e9，AMD EPYC单核可承载，对称2Gbps探测更快）
net.ipv4.tcp_bbr_rtt_scaling = 2                 # RTT敏感度2（从3→2，对称带宽延迟更稳定，减少BBR速率波动）
net.ipv4.tcp_bbr_low_gain = 1100000000           # 低增益1.1e9（从1.2e9→1.1e9，丢包后快速恢复，FQ_PIE减少丢包频率）
net.ipv4.tcp_slow_start_after_idle = 0            # 空闲不重置慢启动（单线程长连接速率不回落，对称带宽持续满速）

# 3. 单线程性能极限调优（对称2Gbps+FQ_PIE适配）
net.ipv4.tcp_limit_output_bytes = 73400320        # 单次发送阈值72MB（从64MB→72MB，匹配80MB窗口，单线程单次发满）
net.ipv4.tcp_single_stream_allowance = 73400320   # 单流允许量72MB（与单次发送同步，FQ_PIE单流优先级保障）
net.ipv4.tcp_push_pending_frames = 1              # 立即发送Pending帧（减少FQ_PIE队列堆积，对称带宽无延迟）
net.ipv4.tcp_nodelay = 1                         # 禁用Nagle算法（单线程低延迟+FQ_PIE高效调度）
net.ipv4.tcp_syn_retries = 2                     # 减少SYN重试（快速建立连接，进入BBR+FQ_PIE协同状态）

# 4. 网络设备队列（对称2Gbps+FQ_PIE联动）
net.core.netdev_max_backlog = 60000               # 接收队列6万（从5.5万→6万，略高于FQ_PIE max_queue_size，避免设备层丢包）
net.core.dev_weight = 180                        # 设备处理权重180（从160→180，AMD EPYC单核承载对称2Gbps极限）
net.core.optmem_max = 4194304                    # 最大选项内存4MB（支撑对称大窗口+FQ_PIE队列选项）
net.core.busy_poll = 55                          # 忙轮询55（从50→55，单核及时处理FQ_PIE调度的上下行数据包）
net.core.busy_read = 50                          # 忙读50（从40→50，下行2Gbps数据接收不阻塞，与上行对称）
net.core.netdev_budget = 900                     # 设备单次处理预算900（从600→900，提升FQ_PIE队列处理效率，匹配对称2Gbps）

# 5. 连接管理（单线程+FQ_PIE公平性）
net.core.somaxconn = 65535                       # 最大连接队列6.5万（保持不变，单线程高并发支撑）
net.ipv4.tcp_max_syn_backlog = 32768             # SYN队列3.2万（保持不变，避免连接建立瓶颈）
net.ipv4.tcp_max_tw_buckets = 1200000            # TIME_WAIT桶120万（从100万→120万，对称带宽多连接回收，无端口耗尽）
net.ipv4.tcp_fin_timeout = 3                     # FIN等待3秒（保持不变，快速释放连接，FQ_PIE队列资源回收）
net.ipv4.tcp_tw_reuse = 1                        # 重用TIME_WAIT连接（保持不变，提升连接复用效率）
net.ipv4.tcp_orphan_retries = 1                  # 孤儿连接重试1次（保持不变，减少单核资源浪费）

# 6. 超时与保活（单线程长连接+对称2Gbps）
net.ipv4.tcp_keepalive_time = 50                  # 保活探测50秒（从60→50，快速检测连接存活，避免FQ_PIE空占队列）
net.ipv4.tcp_keepalive_intvl = 7                  # 保活间隔7秒（从8→7，高频探测，避免对称带宽下连接意外断开）
net.ipv4.tcp_keepalive_probes = 3                 # 保活探测3次（保持不变，快速确认状态）
net.ipv4.ip_local_port_range = 1024 65535         # 端口范围最大化（保持不变，单线程多连接无端口限制）

# 7. 内存管理（对称大窗口+FQ_PIE安全保障）
vm.swappiness = 18                                # 适度交换18（从15→18，1G内存保护，应对对称2Gbps突发内存占用）
vm.min_free_kbytes = 131072                      # 保留空闲内存128MB（从96MB→128MB，对称窗口增大后，保障内存冗余）
vm.dirty_ratio = 25                               # 脏页比率25%（保持不变，单线程写数据暂存，减少I/O阻塞）
vm.dirty_background_ratio = 12                    # 后台脏页比率12%（保持不变，提前写回，避免I/O拖慢队列）
vm.dirty_writeback_centisecs = 180                # 脏页写回180ms（从200→180，数据落盘更快，适配对称带宽I/O需求）
vm.page-cluster = 0                               # 禁用页面聚类（保持不变，避免内存碎片化）
vm.max_map_count = 131072                         # 内存映射限制13万（保持不变，支撑对称大窗口映射）

# 8. 系统限制（单线程+对称2Gbps资源）
fs.file-max = 1200000                            # 文件描述符120万（从100万→120万，对称带宽多连接无句柄限制）
fs.nr_open = 2400000                            # 进程文件描述符240万（从200万→240万，单进程资源冗余）
net.ipv4.ip_unprivileged_port_start = 0           # 允许所有端口使用（保持不变，单线程灵活绑定）

# 9. 处理器调度（AMD EPYC单核+对称2Gbps）
kernel.sched_migration_cost_ns = 650000           # 进程迁移成本65万（从60万→65万，避免单核进程切换，专注队列处理）
kernel.sched_autogroup_enabled = 1                # 启用自动分组（保持不变，单核资源集中给单线程）
kernel.sched_latency_ns = 2800000                 # 调度延迟2.8ms（从3ms→2.8ms，单核响应更快，及时处理上下行数据包）
kernel.sched_wakeup_granularity_ns = 650000       # 唤醒粒度0.65ms（从0.7ms→0.65ms，单线程抢占CPU更快，无延迟）
kernel.sched_rt_runtime_us = -1                   # 实时调度无限制（保持不变，单线程可满负荷运行）

# 10. 硬件加速（单核承载对称2Gbps关键）
net.ipv4.tcp_tso = 1                              # 启用TCP分段卸载（必开！网卡承担分段，单核专注FQ_PIE调度）
net.ipv4.tcp_gro = 1                              # 启用通用接收卸载（必开！网卡合并上下行数据包，减少单核压力）
net.ipv4.tcp_lro = 0                              # 禁用大型接收卸载（单核处理不了，避免丢包影响队列）
