# 0. FQ_PIE队列算法核心配置（全局启用+对称1Gbps适配）
net.core.default_qdisc = fq_pie                  # 全局默认队列算法保持FQ_PIE
net.ipv4.tcp_congestion_control = bbr            # 拥塞控制保持BBR，与FQ_PIE协同优化
# FQ_PIE关键参数（匹配对称1Gbps带宽）
net.core.fq_pie.target_delay = 15                # 目标延迟15ms（低带宽下适度放宽，平衡吞吐量与延迟）
net.core.fq_pie.max_queue_size = 27500           # 最大队列长度2.75万包（4Gbps配置的1/4，缓冲约0.03秒）
net.core.fq_pie.packet_limit = 1250              # 单个流最大数据包限制1250（4Gbps配置的1/4，适配1Gbps单线程）
net.core.fq_pie.alpha = 8                        # alpha系数8（适度提高惩罚力度，低带宽下控制拥塞更严格）
net.core.fq_pie.beta = 16                        # beta系数16（与alpha匹配，增强拥塞响应）
net.core.fq_pie.max_burst = 60                   # 最大突发数据包60（4Gbps配置的1/4，适配1Gbps突发窗口）

# 1. TCP窗口核心配置（对称1Gbps单线程满速）
net.ipv4.tcp_rmem = 2097152 16777216 41943040    # 接收窗口（下行）：2MB - 16MB - 40MB（4Gbps配置的1/4）
net.ipv4.tcp_wmem = 2097152 16777216 41943040    # 发送窗口（上行）：2MB - 16MB - 40MB（与下行对称）
net.core.rmem_default = 12079595520              # 默认接收缓冲区12MB（4Gbps配置的1/4，初始速率拉满1Gbps）
net.core.wmem_default = 12079595520              # 默认发送缓冲区12MB（与下行对称）
net.core.rmem_max = 41943040                     # 最大接收缓冲区40MB（4Gbps配置的1/4，1Gbps硬上限）
net.core.wmem_max = 41943040                     # 最大发送缓冲区40MB（与下行对称）
net.ipv4.tcp_window_scaling = 1                  # 启用窗口缩放（支撑40MB窗口）
net.ipv4.tcp_moderate_rcvbuf = 0                 # 禁用智能缓冲区（锁定窗口大小，适配小内存）
net.ipv4.tcp_adv_win_scale = 1                   # 窗口缩放因子调整（平衡内存占用与吞吐量）

# 2. BBR拥塞控制（对称1Gbps优化）
net.ipv4.tcp_bbr_high_gain = 3000000000          # 激进增益3.0e9（适配AMD EPYC单核，降低探测强度）
net.ipv4.tcp_bbr_rtt_scaling = 3                 # RTT敏感度3（低带宽下提高稳定性，减少波动）
net.ipv4.tcp_bbr_low_gain = 1200000000           # 低增益1.2e9（适度提高恢复力度，适配1Gbps重传需求）
net.ipv4.tcp_slow_start_after_idle = 0            # 空闲不重置慢启动（保持长连接速率稳定）

# 3. 单线程性能极限调优（对称1Gbps+FQ_PIE适配）
net.ipv4.tcp_limit_output_bytes = 36700160        # 单次发送阈值36MB（4Gbps配置的1/4，匹配40MB窗口）
net.ipv4.tcp_single_stream_allowance = 36700160   # 单流允许量36MB（与单次发送同步）
net.ipv4.tcp_push_pending_frames = 1              # 立即发送Pending帧（减少队列堆积）
net.ipv4.tcp_nodelay = 1                         # 禁用Nagle算法（低延迟+FQ_PIE调度）
net.ipv4.tcp_syn_retries = 3                     # SYN重试3次（低带宽下提高连接建立成功率）

# 4. 网络设备队列（对称1Gbps+FQ_PIE联动）
net.core.netdev_max_backlog = 30000               # 接收队列3万（4Gbps配置的1/4，略高于FQ_PIE max_queue_size）
net.core.dev_weight = 80                         # 设备处理权重80（适配AMD EPYC单核处理能力）
net.core.optmem_max = 2097152                    # 最大选项内存2MB（4Gbps配置的1/4，节省内存）
net.core.busy_poll = 60                          # 忙轮询60（单核场景提高数据包处理及时性）
net.core.busy_read = 55                          # 忙读55（增强单核数据接收能力）
net.core.netdev_budget = 400                     # 设备单次处理预算400（适配1Gbps处理需求）

# 5. 连接管理（单核+小内存+FQ_PIE公平性）
net.core.somaxconn = 32768                       # 最大连接队列3.2万（4Gbps配置的1/4，适配小内存）
net.ipv4.tcp_max_syn_backlog = 16384             # SYN队列1.6万（4Gbps配置的1/4）
net.ipv4.tcp_max_tw_buckets = 600000             # TIME_WAIT桶60万（4Gbps配置的1/4，减少内存占用）
net.ipv4.tcp_fin_timeout = 5                     # FIN等待5秒（适度延长，小内存下减少连接重建开销）
net.ipv4.tcp_tw_reuse = 1                        # 重用TIME_WAIT连接
net.ipv4.tcp_orphan_retries = 2                  # 孤儿连接重试2次（提高小内存下连接稳定性）

# 6. 超时与保活（单核+1Gbps）
net.ipv4.tcp_keepalive_time = 60                 # 保活探测60秒（延长间隔，减少小内存下资源消耗）
net.ipv4.tcp_keepalive_intvl = 10                # 保活间隔10秒（降低频率，节省CPU资源）
net.ipv4.tcp_keepalive_probes = 4                # 保活探测4次（提高弱网环境下的连接保持能力）
net.ipv4.ip_local_port_range = 32768 65535       # 端口范围缩小（小内存下减少端口资源占用）

# 7. 内存管理（0.5G内存+1Gbps适配）
vm.swappiness = 60                               # 交换比例60（小内存下提高交换积极性，避免OOM）
vm.min_free_kbytes = 32768                       # 保留空闲内存32MB（适配0.5G总内存，保障系统基础运行）
vm.dirty_ratio = 15                              # 脏页比率15%（降低阈值，减少小内存下I/O阻塞）
vm.dirty_background_ratio = 8                    # 后台脏页比率8%（提前触发写回，控制内存占用）
vm.dirty_writeback_centisecs = 250               # 脏页写回250ms（延长间隔，减少I/O频率）
vm.page-cluster = 0                              # 禁用页面聚类（小内存下避免内存碎片化）
vm.max_map_count = 65536                         # 内存映射限制6.5万（4Gbps配置的1/4，节省内存）

# 8. 系统限制（1核+0.5G内存+1Gbps带宽）
fs.file-max = 600000                             # 文件描述符60万（4Gbps配置的1/4，适配小内存）
fs.nr_open = 1200000                            # 进程文件描述符120万（4Gbps配置的1/4）
net.ipv4.ip_unprivileged_port_start = 1024       # 限制非特权端口起始值（增强安全性，减少资源浪费）

# 9. 处理器调度（AMD EPYC 7551 1核优化）
kernel.sched_migration_cost_ns = 1000000         # 进程迁移成本100万（大幅提高，避免单核进程切换）
kernel.sched_autogroup_enabled = 0               # 禁用自动分组（单核场景集中资源）
kernel.sched_latency_ns = 4000000                # 调度延迟4ms（单核场景放宽，减少调度开销）
kernel.sched_wakeup_granularity_ns = 800000      # 唤醒粒度0.8ms（平衡响应与开销）
kernel.sched_rt_runtime_us = -1                  # 实时调度无限制（单核满负荷利用）
kernel.sched_nr_migrate = 0                      # 禁止任务迁移（锁定单核处理）

# 10. 硬件加速（AMD EPYC 1核+1Gbps关键）
net.ipv4.tcp_tso = 1                             # 启用TCP分段卸载（网卡承担分段，减轻单核负载）
net.ipv4.tcp_gro = 1                             # 启用通用接收卸载（网卡合并数据包）
net.ipv4.tcp_lro = 0                             # 禁用大型接收卸载（单核处理能力有限，避免丢包）
net.core.netdev_tstamp_prequeue = 0              # 禁用时间戳预队列（节省单核资源）
