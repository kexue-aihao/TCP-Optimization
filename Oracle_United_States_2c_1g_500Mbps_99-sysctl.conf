# 0. FQ_PIE队列算法核心配置（全局启用+对称0.5Gbps适配）
net.core.default_qdisc = fq_pie                  # 全局默认队列算法保持FQ_PIE
net.ipv4.tcp_congestion_control = bbr            # 拥塞控制保持BBR，与FQ_PIE协同优化
# FQ_PIE关键参数（匹配对称0.5Gbps带宽）
net.core.fq_pie.target_delay = 20                # 目标延迟20ms（0.5Gbps适度放宽，平衡吞吐量与延迟）
net.core.fq_pie.max_queue_size = 13750           # 最大队列长度1.375万包（0.5Gbps为1Gbps的1/2，缓冲约0.03秒）
net.core.fq_pie.packet_limit = 625               # 单个流最大数据包限制625（0.5Gbps为1Gbps的1/2，适配单线程）
net.core.fq_pie.alpha = 10                       # alpha系数10（低带宽下适度提高惩罚力度）
net.core.fq_pie.beta = 20                        # beta系数20（与alpha匹配，增强拥塞响应）
net.core.fq_pie.max_burst = 30                   # 最大突发数据包30（0.5Gbps为1Gbps的1/2，适配突发窗口）

# 1. TCP窗口核心配置（对称0.5Gbps单线程满速）
net.ipv4.tcp_rmem = 1048576 8388608 20971520     # 接收窗口（下行）：1MB - 8MB - 20MB（0.5Gbps为1Gbps的1/2）
net.ipv4.tcp_wmem = 1048576 8388608 20971520     # 发送窗口（上行）：1MB - 8MB - 20MB（与下行对称）
net.core.rmem_default = 6039797760               # 默认接收缓冲区6MB（0.5Gbps为1Gbps的1/2，初始速率拉满）
net.core.wmem_default = 6039797760               # 默认发送缓冲区6MB（与下行对称）
net.core.rmem_max = 20971520                     # 最大接收缓冲区20MB（0.5Gbps为1Gbps的1/2，硬上限）
net.core.wmem_max = 20971520                     # 最大发送缓冲区20MB（与下行对称）
net.ipv4.tcp_window_scaling = 1                  # 启用窗口缩放（支撑20MB窗口）
net.ipv4.tcp_moderate_rcvbuf = 0                 # 禁用智能缓冲区（锁定窗口大小，适配内存）
net.ipv4.tcp_adv_win_scale = 1                   # 窗口缩放因子调整（平衡内存占用与吞吐量）

# 2. BBR拥塞控制（对称0.5Gbps优化）
net.ipv4.tcp_bbr_high_gain = 2500000000          # 激进增益2.5e9（适配2核，降低探测强度）
net.ipv4.tcp_bbr_rtt_scaling = 4                 # RTT敏感度4（低带宽下提高稳定性，减少波动）
net.ipv4.tcp_bbr_low_gain = 1000000000           # 低增益1.0e9（适配0.5Gbps重传需求）
net.ipv4.tcp_slow_start_after_idle = 0            # 空闲不重置慢启动（保持长连接速率稳定）

# 3. 单线程性能极限调优（对称0.5Gbps+FQ_PIE适配）
net.ipv4.tcp_limit_output_bytes = 18350080        # 单次发送阈值18MB（0.5Gbps为1Gbps的1/2，匹配20MB窗口）
net.ipv4.tcp_single_stream_allowance = 18350080   # 单流允许量18MB（与单次发送同步）
net.ipv4.tcp_push_pending_frames = 1              # 立即发送Pending帧（减少队列堆积）
net.ipv4.tcp_nodelay = 1                         # 禁用Nagle算法（低延迟+FQ_PIE调度）
net.ipv4.tcp_syn_retries = 4                     # SYN重试4次（0.5Gbps下提高连接建立成功率）

# 4. 网络设备队列（对称0.5Gbps+FQ_PIE联动）
net.core.netdev_max_backlog = 15000               # 接收队列1.5万（0.5Gbps为1Gbps的1/2，略高于FQ_PIE max_queue_size）
net.core.dev_weight = 160                        # 设备处理权重160（2核为1核的2倍，适配多核处理能力）
net.core.optmem_max = 1048576                    # 最大选项内存1MB（0.5Gbps为1Gbps的1/2，节省内存）
net.core.busy_poll = 40                          # 忙轮询40（2核场景降低轮询开销，平衡CPU占用）
net.core.busy_read = 35                          # 忙读35（多核数据接收能力增强，降低开销）
net.core.netdev_budget = 200                     # 设备单次处理预算200（0.5Gbps为1Gbps的1/2）

# 5. 连接管理（2核+1G内存+FQ_PIE公平性）
net.core.somaxconn = 65536                       # 最大连接队列6.5万（1G内存为0.5G的2倍，提升并发能力）
net.ipv4.tcp_max_syn_backlog = 32768             # SYN队列3.2万（1G内存为0.5G的2倍）
net.ipv4.tcp_max_tw_buckets = 1200000            # TIME_WAIT桶120万（1G内存为0.5G的2倍，减少内存压力）
net.ipv4.tcp_fin_timeout = 4                     # FIN等待4秒（1G内存下缩短，加速连接回收）
net.ipv4.tcp_tw_reuse = 1                        # 重用TIME_WAIT连接
net.ipv4.tcp_orphan_retries = 3                  # 孤儿连接重试3次（1G内存下提高连接稳定性）

# 6. 超时与保活（2核+1Gbps）
net.ipv4.tcp_keepalive_time = 45                 # 保活探测45秒（1G内存下缩短间隔，及时释放无效连接）
net.ipv4.tcp_keepalive_intvl = 8                 # 保活间隔8秒（提高频率，增强连接检测灵敏度）
net.ipv4.tcp_keepalive_probes = 5                # 保活探测5次（提高弱网环境下的连接保持能力）
net.ipv4.ip_local_port_range = 20000 65535       # 端口范围适中（1G内存下增加可用端口数）

# 7. 内存管理（1G内存+0.5Gbps适配）
vm.swappiness = 50                               # 交换比例50（1G内存下降低交换积极性，减少I/O）
vm.min_free_kbytes = 65536                       # 保留空闲内存64MB（1G内存适配，保障系统基础运行）
vm.dirty_ratio = 20                              # 脏页比率20%（1G内存下提高阈值，减少I/O频率）
vm.dirty_background_ratio = 10                   # 后台脏页比率10%（提前触发写回，控制内存占用）
vm.dirty_writeback_centisecs = 300               # 脏页写回300ms（延长间隔，减少I/O开销）
vm.page-cluster = 1                              # 页面聚类1（1G内存下适度启用，减少碎片同时提高效率）
vm.max_map_count = 131072                        # 内存映射限制13.1万（1G内存为0.5G的2倍）

# 8. 系统限制（2核+1G内存+0.5Gbps带宽）
fs.file-max = 1200000                            # 文件描述符120万（1G内存为0.5G的2倍，提升并发）
fs.nr_open = 2400000                            # 进程文件描述符240万（1G内存为0.5G的2倍）
net.ipv4.ip_unprivileged_port_start = 1024       # 限制非特权端口起始值（增强安全性）

# 9. 处理器调度（AMD EPYC 7551 2核优化）
kernel.sched_migration_cost_ns = 500000          # 进程迁移成本50万（2核场景允许适度迁移，平衡负载）
kernel.sched_autogroup_enabled = 1               # 启用自动分组（2核场景优化任务分布）
kernel.sched_latency_ns = 2000000                # 调度延迟2ms（2核场景缩短，提高响应速度）
kernel.sched_wakeup_granularity_ns = 600000      # 唤醒粒度0.6ms（平衡响应与多核调度开销）
kernel.sched_rt_runtime_us = -1                  # 实时调度无限制（2核满负荷利用）
kernel.sched_nr_migrate = 2                      # 任务迁移数量2（允许适度迁移，均衡2核负载）

# 10. 硬件加速（AMD EPYC 2核+0.5Gbps关键）
net.ipv4.tcp_tso = 1                             # 启用TCP分段卸载（网卡承担分段，减轻CPU负载）
net.ipv4.tcp_gro = 1                             # 启用通用接收卸载（网卡合并数据包）
net.ipv4.tcp_lro = 0                             # 禁用大型接收卸载（避免数据包堆积）
net.core.netdev_tstamp_prequeue = 0              # 禁用时间戳预队列（节省CPU资源）

net.ipv6.conf.all.disable_ipv6 = 1
net.ipv6.conf.default.disable_ipv6 = 1
net.ipv6.conf.lo.disable_ipv6 = 1
