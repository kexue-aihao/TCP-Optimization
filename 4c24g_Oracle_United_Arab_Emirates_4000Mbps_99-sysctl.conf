# 0. FQ_PIE队列算法核心配置（全局启用+对称4Gbps适配）
net.core.default_qdisc = fq_pie                  # 全局默认队列算法保持FQ_PIE
net.ipv4.tcp_congestion_control = bbr            # 拥塞控制保持BBR，与FQ_PIE协同优化
# FQ_PIE关键参数（匹配对称4Gbps带宽）
net.core.fq_pie.target_delay = 10                # 目标延迟10ms（带宽提升后适度降低，控制队列延迟）
net.core.fq_pie.max_queue_size = 110000          # 最大队列长度11万包（2Gbps的2倍，缓冲约0.03秒）
net.core.fq_pie.packet_limit = 5000              # 单个流最大数据包限制5000（2Gbps的2倍，保障单线程满速）
net.core.fq_pie.alpha = 6                        # alpha系数6（略降低惩罚力度，适配更高带宽稳定性）
net.core.fq_pie.beta = 12                        # beta系数12（与alpha匹配，平衡拥塞响应）
net.core.fq_pie.max_burst = 240                  # 最大突发数据包240（2Gbps的2倍，适配BBR突发窗口）

# 1. TCP窗口核心配置（对称4Gbps单线程满速）
net.ipv4.tcp_rmem = 8388608 67108864 167772160   # 接收窗口（下行）：8MB - 66MB - 160MB（2Gbps的2倍）
net.ipv4.tcp_wmem = 8388608 67108864 167772160   # 发送窗口（上行）：8MB - 66MB - 160MB（与下行对称）
net.core.rmem_default = 48318382080              # 默认接收缓冲区48MB（2Gbps的2倍，初始速率拉满）
net.core.wmem_default = 48318382080              # 默认发送缓冲区48MB（与下行对称）
net.core.rmem_max = 167772160                    # 最大接收缓冲区160MB（2Gbps的2倍，4Gbps硬上限）
net.core.wmem_max = 167772160                    # 最大发送缓冲区160MB（与下行对称）
net.ipv4.tcp_window_scaling = 1                  # 启用窗口缩放（支撑160MB大窗口）
net.ipv4.tcp_moderate_rcvbuf = 0                 # 禁用智能缓冲区（锁定大窗口）
net.ipv4.tcp_adv_win_scale = 0                   # 窗口缩放因子最大化（实际可用窗口100%利用）

# 2. BBR拥塞控制（对称4Gbps优化）
net.ipv4.tcp_bbr_high_gain = 3600000000          # 激进增益3.6e9（适配Neoverse-N1性能，加速4Gbps探测）
net.ipv4.tcp_bbr_rtt_scaling = 1                 # RTT敏感度1（减少高带宽下的速率波动）
net.ipv4.tcp_bbr_low_gain = 1000000000           # 低增益1.0e9（丢包后更快恢复）
net.ipv4.tcp_slow_start_after_idle = 0            # 空闲不重置慢启动（保持长连接速率稳定）

# 3. 单线程性能极限调优（对称4Gbps+FQ_PIE适配）
net.ipv4.tcp_limit_output_bytes = 146800640       # 单次发送阈值144MB（匹配160MB窗口）
net.ipv4.tcp_single_stream_allowance = 146800640  # 单流允许量144MB（与单次发送同步）
net.ipv4.tcp_push_pending_frames = 1              # 立即发送Pending帧（减少队列堆积）
net.ipv4.tcp_nodelay = 1                         # 禁用Nagle算法（低延迟+FQ_PIE调度）
net.ipv4.tcp_syn_retries = 2                     # 减少SYN重试（快速建立连接）

# 4. 网络设备队列（对称4Gbps+FQ_PIE联动）
net.core.netdev_max_backlog = 120000              # 接收队列12万（2Gbps的2倍，略高于FQ_PIE max_queue_size）
net.core.dev_weight = 320                        # 设备处理权重320（适配Neoverse-N1 4核处理能力）
net.core.optmem_max = 8388608                    # 最大选项内存8MB（2Gbps的2倍）
net.core.busy_poll = 45                          # 忙轮询45（Neoverse-N1性能优化，及时处理数据包）
net.core.busy_read = 40                          # 忙读40（优化4核并行处理能力）
net.core.netdev_budget = 1600                    # 设备单次处理预算1600（提升队列处理效率）

# 5. 连接管理（多核心+FQ_PIE公平性）
net.core.somaxconn = 131072                      # 最大连接队列13万（2Gbps的2倍）
net.ipv4.tcp_max_syn_backlog = 65536             # SYN队列6.5万（2Gbps的2倍）
net.ipv4.tcp_max_tw_buckets = 2400000            # TIME_WAIT桶240万（2Gbps的2倍）
net.ipv4.tcp_fin_timeout = 3                     # FIN等待3秒（快速释放资源）
net.ipv4.tcp_tw_reuse = 1                        # 重用TIME_WAIT连接
net.ipv4.tcp_orphan_retries = 1                  # 孤儿连接重试1次

# 6. 超时与保活（多连接+对称4Gbps）
net.ipv4.tcp_keepalive_time = 40                 # 保活探测40秒（更快检测连接状态）
net.ipv4.tcp_keepalive_intvl = 6                 # 保活间隔6秒（高频探测）
net.ipv4.tcp_keepalive_probes = 3                # 保活探测3次
net.ipv4.ip_local_port_range = 1024 65535        # 端口范围最大化

# 7. 内存管理（24G内存+对称大窗口）
vm.swappiness = 10                               # 交换比例10（24G大内存下降低交换频率）
vm.min_free_kbytes = 524288                      # 保留空闲内存512MB（适配24G内存，保障系统稳定性）
vm.dirty_ratio = 30                              # 脏页比率30%（提高缓存能力）
vm.dirty_background_ratio = 15                   # 后台脏页比率15%（提前写回）
vm.dirty_writeback_centisecs = 150               # 脏页写回150ms（加速数据落盘）
vm.page-cluster = 2                              # 页面聚类2（适度预读，提升大内存效率）
vm.max_map_count = 262144                        # 内存映射限制26万（2Gbps的2倍）

# 8. 系统限制（4核+24G内存+4Gbps带宽）
fs.file-max = 2400000                            # 文件描述符240万（2Gbps的2倍）
fs.nr_open = 4800000                            # 进程文件描述符480万（2Gbps的2倍）
net.ipv4.ip_unprivileged_port_start = 0          # 允许所有端口使用

# 9. 处理器调度（Neoverse-N1 4核优化）
kernel.sched_migration_cost_ns = 500000          # 进程迁移成本50万（优化4核负载均衡）
kernel.sched_autogroup_enabled = 1               # 启用自动分组（优化多核心资源分配）
kernel.sched_latency_ns = 3000000                # 调度延迟3ms（适配Neoverse-N1特性）
kernel.sched_wakeup_granularity_ns = 700000      # 唤醒粒度0.7ms（平衡响应速度与负载）
kernel.sched_rt_runtime_us = 950000              # 实时调度限制95%（保留系统响应余量）
kernel.sched_nr_migrate = 4                      # 每次迁移4个任务（匹配4核架构）

# 10. 硬件加速（Neoverse-N1+4Gbps关键）
net.ipv4.tcp_tso = 1                             # 启用TCP分段卸载（网卡承担分段）
net.ipv4.tcp_gro = 1                             # 启用通用接收卸载（网卡合并数据包）
net.ipv4.tcp_lro = 1                             # 启用大型接收卸载（Neoverse-N1 4核可处理）
net.core.netdev_tstamp_prequeue = 1              # 启用时间戳预队列（提升时间精度）
